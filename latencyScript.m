

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%load data generated by the Oostenveld script
dataprefix = '../orig'; %folder where the preprocessed data is stored
load(fullfile(dataprefix,'timelock_unfamiliar_cmb'));
load(fullfile(dataprefix,'timelock_famous_cmb'));
load(fullfile(dataprefix,'timelock_scrambled_cmb'));
load(fullfile(dataprefix,'timelock_faces_cmb'));

%extract information on time and channels
time      = timelock_famous_cmb{1}.time;
chanName  = timelock_famous_cmb{1}.label;

%baseline correction
%the baseline currently is at 0.5 x 10e-12, because of the combination of
%two gradiometers by root-mean-square; this is removed, because it would
%confound various latency measures and makes interpretation of some 
%paramters more cumbersome

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a little bit of pre-processing to bring it into format more convenient for me
nSubs  = length(timelock_faces_cmb);
nElecs = size(timelock_faces_cmb{1}.avg,1);
nTime  = size(timelock_faces_cmb{1}.avg,2);
famous     = nan(nSubs,nElecs,nTime);
unfamiliar = nan(nSubs,nElecs,nTime);
scrambled  = nan(nSubs,nElecs,nTime);
faces      = nan(nSubs,nElecs,nTime);
xlimits    = [-0.2 1.0];
baseline   = [-0.2 0.0];
baselinei  = getindexfromtime(time,baseline);
for subi=1:nSubs
    figure(10+subi);
    famous(subi,:,:) = baseline_correction(timelock_famous_cmb{subi}.avg,baselinei(1):baselinei(2));
    subplot(4,1,1)
    plot(time,squeeze(famous(subi,:,:)),'g');
    xlim(xlimits);
    legend('famous');
    title(sprintf('Subject: %02d',subi));

    unfamiliar(subi,:,:) = baseline_correction(timelock_unfamiliar_cmb{subi}.avg,baselinei(1):baselinei(2));
    subplot(4,1,2)
    plot(time,squeeze(unfamiliar(subi,:,:)),'b');
    xlim(xlimits);
    legend('unfamiliar');
    
    scrambled(subi,:,:) = baseline_correction(timelock_scrambled_cmb{subi}.avg,baselinei(1):baselinei(2));
    subplot(4,1,3)
    plot(time,squeeze(scrambled(subi,:,:)),'k');
    xlim(xlimits);
    legend('scrambled');
    
    faces(subi,:,:) = baseline_correction(timelock_faces_cmb{subi}.avg,baselinei(1):baselinei(2));
    subplot(4,1,4)
    plot(time,squeeze(faces(subi,:,:)),'r');
    xlim(xlimits);
    legend('faces');
   
end
meanERF=(scrambled + faces) / 2;

%baseline correction
%the baseline currently is at 0.5 x 10e-12, because of the combination of
%two gradiometers by root-mean-square; this is removed, because it would
%confound various latency measures and makes interpretation of some 
%paramters more cumbersome

%extract information on time and channels
time      = timelock_famous_cmb{1}.time;
sfreq     = 1/(timelock_famous_cmb{1}.time(2)-timelock_famous_cmb{1}.time(1));
time_in_seconds = true;
% time_in_seconds = false;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Figures - run all code in given order to reproduce results!
%(figures are created without timing information, so that everything is
%expressed in sampling points with 0 as the start of the baseline) 

%settings applying to all figures
cfg = [];
cfg.sign      = 1;    %search for a positive component
cfg.chans     = find(strcmp(chanName,'MEG0712+0713')); %set channel to analyze
cfg.peakWidth = 5;    %set peak width (5 is default anyway)
if time_in_seconds
    cfg.times     = time;
    cfg.sampRate  = sfreq;
    cfg.peakWidth = cfg.peakWidth/sfreq;    %set peak width (5 is default anyway)
end
cfg.fig       = true; %request figures for individual averages


%% Figure 1
cfg.extract   = {'peakLat','onset','offset','areaLat'}; %choose all desired latency measures
cfg.percAmp   = 0.3;        %determines on- and offset
cfg.peakWin   = [600 800];  %search window for early component
if time_in_seconds
    cfg.peakWin   = (cfg.peakWin-1)/sfreq + time(1); %search window for early component
end
[ res, ~] = latency(cfg,famous);        %Figure 1, early component
%% Bar graph with results
results = [res.onset  res.peakLat res.areaLat res.offset ];
if time_in_seconds
    figure(111); modstr = 'seconds';
else
    figure(110); modstr = 'samples';
end
bh=bar(results);
legend({'Onset','PeakLat','AreaLat','Offset'},'Location','northwest');
legend('boxoff');
xticklabels=cell(1,nSubs);
for i=1:nSubs
   xticklabels{i} = sprintf('%d',i); 
end
set(gca,'XTick',1:nSubs,'XTickLabel',xticklabels);

bh(1).FaceColor = 'flat';
bh(1).CData = repmat(bh(1).Parent.ColorOrder(3,:)',1,nSubs)';
bh(2).FaceColor = 'flat';
bh(2).CData = repmat(bh(1).Parent.ColorOrder(1,:)',1,nSubs)';
bh(3).FaceColor = 'flat';
bh(3).CData = repmat(bh(1).Parent.ColorOrder(5,:)',1,nSubs)';
bh(4).FaceColor = 'flat';
bh(4).CData = repmat(bh(1).Parent.ColorOrder(4,:)',1,nSubs)';
title(['Early component - famous, time in ' modstr]);
%%
cfg.peakWin   = [900 1870]; %search window for late component
if time_in_seconds
        cfg.peakWin   = (cfg.peakWin-1)/sfreq + time(1); %search window for late component
end
[ res, ~] = latency(cfg,famous);        %Figure 2, late component

%% Bar graph with results
results = [res.onset  res.peakLat res.areaLat res.offset ];
if time_in_seconds
    figure(121); modstr = 'seconds';
else
    figure(120); modstr = 'samples';
end
bh=bar(results);
legend({'Onset','PeakLat','AreaLat','Offset'},'Location','northwest');
legend('boxoff');
xticklabels=cell(1,nSubs);
for i=1:nSubs
   xticklabels{i} = sprintf('%d',i); 
end
set(gca,'XTick',1:nSubs,'XTickLabel',xticklabels);

bh(1).FaceColor = 'flat';
bh(1).CData = repmat(bh(1).Parent.ColorOrder(3,:)',1,nSubs)';
bh(2).FaceColor = 'flat';
bh(2).CData = repmat(bh(1).Parent.ColorOrder(1,:)',1,nSubs)';
bh(3).FaceColor = 'flat';
bh(3).CData = repmat(bh(1).Parent.ColorOrder(5,:)',1,nSubs)';
bh(4).FaceColor = 'flat';
bh(4).CData = repmat(bh(1).Parent.ColorOrder(4,:)',1,nSubs)';
title(['Late component - famous, time in ' modstr]);


%% Figure 2
cfg.extract = 'areaLat';    %request only percent-area latency
latency(cfg,unfamiliar);    %Figure 2A and 2B


%Figure 3
latency(cfg,unfamiliar);    %Figure 3A (same call as Figure 2)

cfg.areaBase = 'percAmp';   %individualize baseline
cfg.percAmp  = 0.3;         %set baseline to 30% of the peak amplitude
latency(cfg,unfamiliar);    %Figure 3B

cfg.cWinWidth = -400;       %use the adjacent peak to find a better baseline
cfg.cWinStart = 'peak';     %start search for the adjacent peak at the peak of interest
latency(cfg,unfamiliar);    %Figure 3C

cfg.areaWin = 'ampLat';     %constrain the area by the on- and offsets
latency(cfg,unfamiliar);    %Figure 3D


%Figure 4
figure('Name','Grand Averages');

fig4a = subplot(2,1,1);
plot(time,squeeze(mean(meanERF(:,cfg.chans,:),1)),'b');
title('GA across conditions')    
%Figure 4A finished

subplot(2,1,2)
plot(time,squeeze(mean(famous(:,cfg.chans,:),1)),'b');
hold on
plot(time,squeeze(mean(unfamiliar(:,cfg.chans,:),1)),'g');
plot(time,squeeze(mean(scrambled(:,cfg.chans,:),1)),'r');
hold off
legend({'Famous','Unfamiliar','Scrambled'}); 
title('GAs for each condition');
%Figure 4B finished
lims=ylim;

set(fig4a,'ylim',lims);          %equate y-scaling

%for time windows and latency measures, see below


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%example analysis - run all code in given order to reproduce results
%(timing information in seconds is submitted to the function so that 
%everything is now expressed in seconds)

cfg = [];
cfg.chanName  = chanName;      %tell the function about the channel names
cfg.times     = time;           %tell the function about the time axis
cfg.sign      = 1;              %search for a positive component
cfg.chans     = 'MEG0712+0713'; %set channel to analyze
cfg.areaWin   = 'ampLat';       %area is confined by the on- and offsets
cfg.percAmp   = 0.3;            %percentage of amplitude for on- and offsets
cfg.percArea  = 0.5;            %defaults to 50% anyway
cfg.peakWin   = [0.4 1.0];      %set window for searching the peak
cfg.cWinWidth = -0.2;           %set window for searching the adjacent peak (relative to cfg.peakWin)


%late component, area latency
cfg.extract   = 'areaLat';      
famAreaLat = latency(cfg,famous);
unfAreaLat = latency(cfg,unfamiliar);
scrAreaLat = latency(cfg,scrambled);
facAreaLat = latency(cfg,faces);

[h,p,ci,stats] = ttest(facAreaLat,scrAreaLat)
mean(facAreaLat-scrAreaLat)
[h,p,ci,stats] = ttest(famAreaLat,unfAreaLat)
mean(famAreaLat-unfAreaLat)


%late component, onset latency
cfg.extract   = 'onset';        
famOnLat = latency(cfg,famous);
unfOnLat = latency(cfg,unfamiliar);
scrOnLat = latency(cfg,scrambled);
facOnLat = latency(cfg,faces);

[h,p,ci,stats] = ttest(facOnLat,scrOnLat)
mean(facOnLat-scrOnLat)
[h,p,ci,stats] = ttest(famOnLat,unfOnLat)
mean(famOnLat-unfOnLat)


%late component, peak latency
cfg.extract   = 'peakLat';      
famPeakLat = latency(cfg,famous);
unfPeakLat = latency(cfg,unfamiliar);
scrPeakLat = latency(cfg,scrambled);
facPeakLat = latency(cfg,faces);

[h,p,ci,stats] = ttest(facPeakLat,scrPeakLat)
mean(facPeakLat-scrPeakLat)
[h,p,ci,stats] = ttest(famPeakLat,unfPeakLat)
mean(famPeakLat-unfPeakLat)


%early component, area latency
cfg.extract   = 'areaLat';
cfg.peakWin   = [0.14 0.24];
cfg.cWinWidth = 0.1;
famEarlyLat = latency(cfg,famous);
unfEarlyLat = latency(cfg,unfamiliar);
scrEarlyLat = latency(cfg,scrambled);
facEarlyLat = latency(cfg,faces);

[h,p,ci,stats] = ttest(facEarlyLat,scrEarlyLat)
mean(facEarlyLat-scrEarlyLat)
[h,p,ci,stats] = ttest(famEarlyLat,unfEarlyLat)
mean(famEarlyLat-unfEarlyLat)



%jackknife peak latency, late component, 
cfg.extract   = 'peakLat';
cfg.peakWin   = [0.4 1.0];      
cfg.cWinWidth = -0.2;

cfg.aggregate = 'jackMiller';
famJackMPeakLat = latency(cfg,famous);
unfJackMPeakLat = latency(cfg,unfamiliar);
scrJackMPeakLat = latency(cfg,scrambled);
facJackMPeakLat = latency(cfg,faces);
res = jackT(facJackMPeakLat,scrJackMPeakLat)
facJackMPeakLat(end) - scrJackMPeakLat(end)
res = jackT(famJackMPeakLat,unfJackMPeakLat)
famJackMPeakLat(end) - unfJackMPeakLat(end)

cfg.aggregate = 'jackSmulders';
famJackSPeakLat = latency(cfg,famous);
unfJackSPeakLat = latency(cfg,unfamiliar);
scrJackSPeakLat = latency(cfg,scrambled);
facJackSPeakLat = latency(cfg,faces);
[h,p,ci,stats] = ttest(facJackSPeakLat,scrJackSPeakLat)
mean(facJackSPeakLat-scrJackSPeakLat)
[h,p,ci,stats] = ttest(famJackSPeakLat,unfJackSPeakLat)
mean(famJackSPeakLat-unfJackSPeakLat)


%jackknife area latency, late component 
cfg.extract = 'areaLat';
cfg.aggregate = 'jackMiller';
famJackLat = latency(cfg,famous);
unfJackLat = latency(cfg,unfamiliar);
scrJackLat = latency(cfg,scrambled);
facJackLat = latency(cfg,faces);
res = jackT(facJackLat,scrJackLat)
facJackLat(end) - scrJackLat(end)
res = jackT(famJackLat,unfJackLat)
famJackLat(end) - unfJackLat(end)

cfg.aggregate = 'jackSmulders';
famJackSLat = latency(cfg,famous);
unfJackSLat = latency(cfg,unfamiliar);
scrJackSLat = latency(cfg,scrambled);
facJackSLat = latency(cfg,faces);
[h,p,ci,stats] = ttest(facJackSLat,scrJackSLat)
mean(facJackSLat-scrJackSLat)
[h,p,ci,stats] = ttest(famJackSLat,unfJackSLat)
mean(famJackSLat-unfJackSLat)


%reliability of various measures
[relA,p] = corr(famAreaLat,unfAreaLat)
[relO,p] = corr(famOnLat,unfOnLat)
[relP,p] = corr(famPeakLat,unfPeakLat)

%intercorrelation of various measures
[r,p] = corr([facAreaLat,facOnLat,facPeakLat])
corr(facAreaLat,facPeakLat)/sqrt(relA*relP)
corr(facAreaLat,facOnLat)/sqrt(relA*relO)
corr(facOnLat,facPeakLat)/sqrt(relO*relP)
